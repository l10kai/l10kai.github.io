<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>readme</title>
    <url>/2024/12/02/readme/</url>
    <content><![CDATA[<p>建站前期，内容正有序添加中</p>
]]></content>
  </entry>
  <entry>
    <title>dijkstra</title>
    <url>/2024/12/04/dijkstra/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dijkstra = [&amp;](<span class="type">int</span> s) &#123;</span><br><span class="line">  vector&lt;i64&gt; <span class="built_in">dis</span>(n, <span class="number">1e18</span>);</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [d, u] = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d != dis[u])</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : v[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">        dis[v] = dis[u] + w;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;dis[v], v&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>exgcd</title>
    <url>/2024/12/04/exgcd/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a * x + b * y = gcd(a, b) 的一组特解</span></span><br><span class="line"><span class="function">pll <span class="title">exgcd</span><span class="params">(i64 a, i64 b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  pll res = <span class="built_in">exgcd</span>(b, a % b);</span><br><span class="line">  <span class="keyword">return</span> &#123;res.se, res.fi - a / b * res.se&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title>i128</title>
    <url>/2024/12/04/i128/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __int128 x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            f=<span class="number">-1</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>i128</tag>
      </tags>
  </entry>
  <entry>
    <title>lca(倍增）</title>
    <url>/2024/12/04/lca(%E5%80%8D%E5%A2%9E%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, k, T;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">17</span>], depth[N], lg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    lg[i] = lg[i - <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>] == i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> father)</span> </span>&#123;</span><br><span class="line">  fa[cur][<span class="number">0</span>] = father;</span><br><span class="line">  depth[cur] = depth[father] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lg[depth[cur]]; ++i) &#123;</span><br><span class="line">    fa[cur][i] = fa[fa[cur][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i : g[cur]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != father)</span><br><span class="line">      <span class="built_in">dfs</span>(i, cur);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (depth[x] &lt; depth[y])</span><br><span class="line">    <span class="built_in">swap</span>(x, y);               <span class="comment">// 不妨假设x深度更大</span></span><br><span class="line">  <span class="keyword">while</span> (depth[x] &gt; depth[y]) <span class="comment">// 跳到同一深度</span></span><br><span class="line">  &#123;</span><br><span class="line">    x = fa[x][lg[depth[x] - depth[y]] - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y)</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> k = lg[depth[x]] - <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) <span class="comment">// 跳到LCA下边一层</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x][k] != fa[y][k]) &#123;</span><br><span class="line">      x = fa[x][k], y = fa[y][k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; root;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  n--;</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="built_in">LCA</span>(x, y);</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>lca(倍增）</tag>
      </tags>
  </entry>
  <entry>
    <title>差分</title>
    <url>/2024/12/04/%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LazySum</span> &#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; ps;</span><br><span class="line">	<span class="built_in">LazySum</span>(<span class="type">int</span> n) : <span class="built_in">ps</span>(n, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//[l, r]</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">		ps[l] += val;</span><br><span class="line">		ps[r + <span class="number">1</span>] -= val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pushToAndClear</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;d)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		fore (i, <span class="number">0</span>, <span class="built_in">sz</span>(ps)) &#123;</span><br><span class="line">			sum += ps[i];</span><br><span class="line">			ps[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; <span class="built_in">sz</span>(d))</span><br><span class="line">				d[i] += sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>二维差分</title>
    <url>/2024/12/04/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> insert = [&amp;](i64 x1, i64 y1, i64 x2, i64 y2, i64 c,</span><br><span class="line">                  vector&lt;vector&lt;i64&gt;&gt; &amp;b) &#123;</span><br><span class="line">  b[x1][y1] += c;</span><br><span class="line">  b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">  b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">  b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> TD_prefix_and = [&amp;](vector&lt;vector&lt;i64&gt;&gt; &amp;b) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">      b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>二维差分</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线周长并</title>
    <url>/2024/12/04/%E6%89%AB%E6%8F%8F%E7%BA%BF%E5%91%A8%E9%95%BF%E5%B9%B6/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, ans, last;  <span class="comment">// last上条底的长度</span></span><br><span class="line"><span class="type">int</span> X[N &lt;&lt; <span class="number">1</span>];       <span class="comment">// 所有横坐标  需离散化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span>  <span class="comment">// 扫描线</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1, x2, y;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125; line[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node2</span>  <span class="comment">// 线段树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> lz, len;  <span class="comment">// len当先扫描到的矩形的长</span></span><br><span class="line">    <span class="type">int</span> sum;      <span class="comment">// 竖边个数</span></span><br><span class="line">    <span class="type">bool</span> lco, rco;</span><br><span class="line">&#125; t[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node1 q, node1 w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q.y == w.y)</span><br><span class="line">        <span class="keyword">return</span> q.flag &gt; w.flag;</span><br><span class="line">    <span class="keyword">return</span> q.y &lt; w.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u * <span class="number">2</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(u * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = t[u].l, r = t[u].r;</span><br><span class="line">    <span class="keyword">if</span> (t[u].lz) &#123;</span><br><span class="line">        t[u].len = X[r + <span class="number">1</span>] - X[l];</span><br><span class="line">        t[u].lco = t[u].rco = <span class="number">1</span>;</span><br><span class="line">        t[u].sum = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t[u].len = t[u &lt;&lt; <span class="number">1</span>].len + t[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">        t[u].sum = t[u &lt;&lt; <span class="number">1</span>].sum + t[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">        t[u].lco = t[u &lt;&lt; <span class="number">1</span>].lco, t[u].rco = t[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rco;</span><br><span class="line">        <span class="keyword">if</span> (t[u &lt;&lt; <span class="number">1</span>].rco &amp;&amp; t[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lco)</span><br><span class="line">            t[u].sum -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[u].l &amp;&amp; t[u].r &lt;= r) &#123;</span><br><span class="line">        t[u].lz += flag;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (t[u].l + t[u].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">        <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, flag);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">        <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, flag);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">    <span class="built_in">memset</span>(X, <span class="number">0</span>, <span class="built_in">sizeof</span>(X));</span><br><span class="line">    <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="built_in">sizeof</span>(line));</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p, p1;  <span class="comment">// 用来离散横坐标 建树空间不会炸</span></span><br><span class="line">    last = tot = ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, x = <span class="number">0</span>, y = <span class="number">0</span>, xx, yy;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; xx &gt;&gt; yy;</span><br><span class="line">        line[i] = &#123;x, xx, y, <span class="number">1</span>&#125;;</span><br><span class="line">        line[i + n] = &#123;x, xx, yy, <span class="number">-1</span>&#125;;</span><br><span class="line">        X[i] = x, X[i + n] = xx;</span><br><span class="line">        p1[x]++;</span><br><span class="line">        p1[xx]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(line + <span class="number">1</span>, line + n * <span class="number">2</span> + <span class="number">1</span>, cmp);  <span class="comment">// 排序完就是从下往上扫</span></span><br><span class="line">    <span class="comment">// 去重 离散</span></span><br><span class="line">    <span class="built_in">sort</span>(X + <span class="number">1</span>, X + <span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">unique</span>(X + <span class="number">1</span>, X + <span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [i, j] : p1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p[i])</span><br><span class="line">            p[i] = ++tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, tot - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l = p[line[i].x1],</span><br><span class="line">            r = p[line[i].x2];  <span class="comment">// 用离散值查到当前扫描到的边的左右横坐标</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, l, r - <span class="number">1</span>, line[i].flag);</span><br><span class="line">        ans = ans + <span class="built_in">abs</span>(last - t[<span class="number">1</span>].len);  <span class="comment">// 横边</span></span><br><span class="line">        last = t[<span class="number">1</span>].len;</span><br><span class="line">        ans =</span><br><span class="line">            ans + t[<span class="number">1</span>].sum * (line[i + <span class="number">1</span>].y - line[i].y);  <span class="comment">// 竖边条数*竖边长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans + line[n * <span class="number">2</span>].x2 - line[n * <span class="number">2</span>].x1;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// init();</span></span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>扫描线周长并</tag>
      </tags>
  </entry>
  <entry>
    <title>点到线段距离</title>
    <url>/2024/12/04/%E7%82%B9%E5%88%B0%E7%BA%BF%E6%AE%B5%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>点到线段距离</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集（dsu）</title>
    <url>/2024/12/04/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88dsu%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123; <span class="built_in">init</span>(n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">      x = f[x] = f[f[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按秩合并</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">      f[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      f[x] = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  bool merge(int x, int y) &#123;</span></span><br><span class="line"><span class="comment">      x = find(x);</span></span><br><span class="line"><span class="comment">      y = find(y);</span></span><br><span class="line"><span class="comment">      if (x == y) &#123;</span></span><br><span class="line"><span class="comment">          return false;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      siz[x] += siz[y];</span></span><br><span class="line"><span class="comment">      f[y] = x;</span></span><br><span class="line"><span class="comment">      return true;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>并查集（dsu）</tag>
      </tags>
  </entry>
  <entry>
    <title>线性筛</title>
    <url>/2024/12/04/%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!st[i])</span><br><span class="line">      primes[cnt++] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++) &#123;</span><br><span class="line">      st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2024/12/04/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add = [&amp;](i64 x, i64 y, vector&lt;i64&gt; &amp;p) &#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x))</span><br><span class="line">    p[x] += y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> query = [&amp;](i64 x, vector&lt;i64&gt; &amp;p) &#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span>(x))</span><br><span class="line">    ans += p[x];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>逆序对</title>
    <url>/2024/12/04/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  i64 res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    <span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">      tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res += mid - i + <span class="number">1</span>;</span><br><span class="line">      tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">    tmp[k++] = q[i++];</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">    tmp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">    q[i] = tmp[j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数(1e5）</title>
    <url>/2024/12/04/%E7%BB%84%E5%90%88%E6%95%B0(1e5%EF%BC%89/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">i64 <span class="title">fpow</span><span class="params">(i64 a, i64 x)</span> </span>&#123;</span><br><span class="line">  i64 res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>)</span><br><span class="line">      res = res * a % mod;</span><br><span class="line">    a = a * a % mod;</span><br><span class="line">    x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> i64 M = <span class="number">1e5</span>;</span><br><span class="line">i64 fac[M + <span class="number">10</span>], fnv[M + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">  fnv[M] = <span class="built_in">fpow</span>(fac[M], mod - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = M; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    fnv[i - <span class="number">1</span>] = fnv[i] * i % mod;</span><br><span class="line">  <span class="comment">// assert(fnv[1] == 1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i64 <span class="title">C</span><span class="params">(i64 n, i64 m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m &lt; <span class="number">0</span> || m &gt; n)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> fac[n] * fnv[m] % mod * fnv[n - m] % mod;</span><br><span class="line">&#125; <span class="comment">// c(n,m)</span></span><br><span class="line"><span class="function">i64 <span class="title">A</span><span class="params">(i64 n, i64 m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m &lt; <span class="number">0</span> || m &gt; n)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> fac[n] * fnv[m] % mod;</span><br><span class="line">&#125; <span class="comment">// a(n,m);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>模板类</category>
      </categories>
      <tags>
        <tag>组合数(1e5）</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器配置frp（基础篇）</title>
    <url>/2024/12/04/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEfrp%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="云服务器配置frp（基础篇）"><a href="#云服务器配置frp（基础篇）" class="headerlink" title="云服务器配置frp（基础篇）"></a>云服务器配置frp（基础篇）</h1><p>本文基于debian11.3系统，云服务器为阿里云轻量应用服务器。该基础篇仅介绍frp服务基本配置，不涉及具体应用场景。</p>
<p>以下所有代码默认以root身份执行</p>
<p>我们选择在 <code>\opt\frp</code>文件夹下部署frp服务，如没有文件夹请提前用<code>mkdir</code>命令创建</p>
<h2 id="下载frp压缩包"><a href="#下载frp压缩包" class="headerlink" title="下载frp压缩包"></a>下载frp压缩包</h2><p>通过<code>cd \opt\frp </code>定位到该文件夹，使用<code>\wget https://github.com/fatedier/frp/releases/download/v0.xx.x/frp_0.xx.x_linux_amd64.tar.gz tar -zxvf frp_0.xx.x_linux_amd64.tar.gz</code>命令下载frp安装包，注意<code>v0.xx.x</code>应严格换成所需版本，本文中 笔者使用的是<code>0.61.0</code>版本，命令即为<code>wget https://github.com/fatedier/frp/releases/download/v0.61.0/frp_0.61.0_linux_amd64.tar.gz </code></p>
<h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p>执行解压缩命令<code>tar -zxvf frp_0.61.0_linux_amd64.tar.gz</code></p>
<p>在当前目录下会出现一个<code>frp_0.61.0_linux_amd64</code>文件夹</p>
<p>文件夹中包含<code>frpc  frpc.toml  frps  frps.toml  LICENSE</code>等四个文件</p>
<p>注意：在较新版本中，已经没有<code>frps.init</code>文件，取而代之的是<code>frpc.toml</code>文件</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>使用nano 或 vim命令对<code>frpc.toml</code>文件稍作修改，参考：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dashboard 配置</span></span><br><span class="line"><span class="attr">webServer.addr</span> = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="attr">webServer.port</span> = <span class="number">7001</span></span><br><span class="line"><span class="attr">webServer.user</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">webServer.password</span> = <span class="string">&quot;password&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><p>在阿里云服务器中，我们只需在服务器控制台中添加规则即可。</p>
<p>在上面的配置中，我们使用了 <code>7000</code>和<code>7001</code>端口，分别添加规则即可</p>
<p>应用类型 为自定义，协议为TCP, 来源为0.0.0.0 都用默认设置即可，自行设置端口范围和备注。</p>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>此时，输入<code>frps -c frps.toml </code>即可启动服务</p>
<p>任选设备在浏览器中输入<code>x.x.x.x:7001</code>，出现如下图页面即为服务开放成功，其中，<code>x.x.x.x</code>为您的服务器公网ip</p>
<h2 id="配置Systemd管理服务"><a href="#配置Systemd管理服务" class="headerlink" title="配置Systemd管理服务"></a>配置Systemd管理服务</h2><p>我们发现输入<code>frps -c frps.toml </code>过于繁琐，且不方便查看服务状态</p>
<p>可以执行<code>nano \etc\systemd\system\frps.service</code> 在<code>\etc\systemd\system\</code>文件夹中创建<code>frps.service</code>文件，写入以下内容：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">Description</span> = frp server</span><br><span class="line"><span class="attr">After</span> = network.target syslog.target</span><br><span class="line"><span class="attr">Wants</span> = network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span> = simple</span><br><span class="line"><span class="comment"># 启动frps</span></span><br><span class="line"><span class="attr">ExecStart</span> = /opt/frp/frp_0.<span class="number">61.0</span>_linux_amd64/frps -c /opt/frp/frp_0.<span class="number">61.0</span>_linux_amd64/frps.toml</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span> = multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，<code>ExecStart = /.../x/frps -c /.../x/frps.toml</code>这一行<code>/.../x/</code>所对应的应为您frps文件和frps.toml文件所对应的地址。</p>
<p>现在我们可以方便的管理服务了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status frps</span><br><span class="line"><span class="comment">#服务状态</span></span><br><span class="line">systemctl start frps</span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">systemctl stop frps</span><br><span class="line"><span class="comment">#停止服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> frps</span><br><span class="line"><span class="comment">#设置开机自启</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
</search>
